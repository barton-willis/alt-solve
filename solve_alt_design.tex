\documentclass[]{article}%{scrartcl}
\usepackage[letterpaper,margin=1.0in]{geometry}

\usepackage[activate={true,nocompatibility},final,tracking=true,kerning=true,spacing=true,factor=1100,stretch=10,shrink=10]{microtype}
\microtypecontext{spacing=nonfrench}
\usepackage[american]{babel}
\usepackage{fourier}
\usepackage{enumitem}
\usepackage{xcolor}
\newlist{alphalist}{enumerate}{3}
\setlist[alphalist]{label=\alph*),before=\raggedright}

\newcommand{\altsolve}{\texttt{solve\_alt}}
\newcommand{\solve}{\texttt{solve}}
\newcommand{\algsys}{\texttt{algsys}}
\newcommand{\solveexplicit}{\texttt{solveexplicit}}
\newcommand{\fpprec}{\texttt{fpprec}}

\newcommand{\multivaluedinverse}{\texttt{multivalued\_inverse}}
\newcommand{\singlevaluedinverse}{\texttt{single\_valued\_inverse}}
\newcommand{\solveinversepackage}{\texttt{solve\_inverse\_package}}
\title{An alternative solve function for Maxima}
\author{Barton Willis}
\begin{document}


\maketitle

\section{Aims}

The \altsolve\/ package aims to be a replacement for Maxima's solve function. The goals are

\begin{alphalist}[noitemsep]

\item to support the needs for a variety users, including high school students, university students, engineers, statisticians, and scientists,

\item to provide clear user documentation that is focused on user's questions,

\item to focus on symbolic solution to equations that are pertinent to science and engineering problems,

\item source code (Common Lisp) that is easy to extend and to fix,

\item to find all real and complex solutions to equations, but take care to not return spurious solutions.

\end{alphalist}
Additionally, \altsolve\/  aims to be compatible with Maxima's current solve function; by compatible, we require:

\begin{alphalist}[noitemsep]

\item  Solutions are expressed as Maxima lists.

 \item The \altsolve\/ code requires only modest modifications to the rest of the source code for  Maxima.

\item Except for algebraically equivalent, but different results, \altsolve\/  runs the testsuite and the share testsuite with no errors and in roughy the same time. This condition should hold for all combinations of the primary option variables that effect functioning of \altsolve.

\item The code compiles and runs under all supported Common Lisp versions that are supported by Maxima.
\end{alphalist}
We do \emph{not} aim
\begin{alphalist}[noitemsep]

\item to solve inequalities, Diophantine equations, differential equations, or to dispatch purely numerical methods (the Newton method, for example) solutions,

\item to build a platform that could be used to display the steps done to find the solution,

\item to write a new version of \algsys.

\end{alphalist}
Our development priorities are (in order from highest to least)

\begin{alphalist}[noitemsep]

\item  to provide well written source code with ample informative comments,

\item to have a modest code size,

\item to be conservative with memory usage,

\item to solve equations quickly.

\end{alphalist}

\section{Use of database facts}

Type declarations on the unknown (for example declare(x, real)) do not limit the solution set to include only integers. But the type declaration might be used inside the solve process in simplfication. So it's possible that a type declartion of an unknown will alter the solution set, but again, the solution set is free to contain members that do not satisfy the delcared types (if any) of the unknowns.

A user who needs only real or integer, or \dots solutions will need to filter the solution set for those members that satisfy other conditions. The function sublist can help with this process.

\section{Solve is an ordinary function}

The function \solve \/ evaluates its input. That makes it an \emph{ordinary} Maxima function. This means, for example, that the function call \(\mathrm{solve}(x/x=1,x)\) is effectively evaluated to \(\mathrm{solve}(1=1,x)\) before \solve \/ starts its work. Efforts to thwart this (by setting simp to false or by quoting) are likely to be unsuccessful.

\section{Representation of solutions}

To be compatible with Maxima, solutions to equations with one variable have the form of a Maxima list; thus a solution has the form \([x = e_1, x = e_2, \cdots, x = e_n]\), where the expressions \(e_1, e_2, \dots, e_n\) are free of \(x\). The order of solutions is \emph{unspecified}. The simple list structure of a solutions allows for the following example to yield true:

\begin{verbatim}
(%i1)	eq : (x-5)*(x-2)=0$
(%i2)	every(map(lambda([q], subst(q, eq)), solve(eq,x)));
(%o2)	true
\end{verbatim}

The solutions should invovle objects that Maxima functions such as sign, mapatom, featurep, and declare understand.

\section{Option variables}

\begin{description}


\item [solveexplicit] (default false) When \altsolve\/  is unable to find a solution and the option variable \solveexplicit\/ is false, return an equivalent, but possibly simplified equation;  otherwise print a message that there is no method for solving the equation and return the empty list.

\item [use\_to\_poly] (default true)  When use\_to\_poly is true, \altsolve\/ is able to solve more algebraic
equations.  Likely there is little reason to set this option variable to false.

\item[solve\_ignores\_conditions] (default false) When this option varaible is false, \altsolve\/ attempts to
remove solutions that are not in the natural domain of the equation; when true, solutions may include those that are outside the domain; for example
\begin{verbatim}
(%i7)	block([solve_ignores_conditions : true], solve( x * (log(x) - 1)  = 0));
(%o7)	[x=%e,x=0]

(%i8)	block([solve_ignores_conditions : false], solve( x * (log(x) - 1)  = 0));
(%o8)	[x=%e]
\end{verbatim}

The correct functioning of this mechanism requires the correct functioning of many other Maxima components. But it is subject various limitations.

\item[solve\_inverse\_package] When solve\_inverse\_package is multivalued\_inverse, \altsolve\/ attemps to find all solutions (both real and complex) to equations; when its value is single\_valued\_inverse, the effort is to find one or more soltions, but primarly a real solution. Examples:
\begin{verbatim}
  (%i1)	block([solve_inverse_package : multivalued_inverse], solve(1.03^x = 5.2));
  (%o1)	[x=33.83087013568215*(2*%i*%pi*%z3+1.648658625587382)]

  (%i2)	block([solve_inverse_package : single_valued_inverse], solve(1.03^x = 5.2));
  (%o2)	[x=55.77555586031892]
\end{verbatim}
For a problem in finiancial math or high school level math, likely is the one that is desired. Another
example is
\begin{verbatim}
(%i1)	block([solve_inverse_package : multivalued_inverse], solve(sin(x) = 1/2));
(%o1)	[x=(12*%pi*%z5+%pi)/6,x=(12*%pi*%z6+5*%pi)/6]

(%i2)	block([solve_inverse_package : single_valued_inverse], solve(sin(x) = 1/2));
(%o2)	[x=%pi/6]
\end{verbatim}

Maxima's integration, especially definite integration code, needs to solve equations. But this code would mostly misbehave using the  multivalued\_inverse package. The \altsolve\/ code automatically sets solve\_inverse\_package to single\_valued\_inverse when inside the integration code.

\end{description}
%I'm not sure what solve(0=0, []) should return. Returning the symbol  \all makes a bit of a mess (a solution cannot be relied on to be a list)






Atoms of the form \%Zk, \%Rk, and \%Ck, where k is a nonnegative integer, represent arbitrary integers, real numbers, and complex numbers, respectively.

Solutions to equations with two or more variables are lists of lists of the form \([x_1 = e_1, x_2 = e_2, \cdots, x_n = e_n] \), where the expressions \(e_1\) through \(e_n\) are free of the symbols \(x_1\) through \(x_n \). The order of variables in each solution is unspecified, and the order of the lists is unspecified.

\section{Keep float mechanism}

The top level solve function encloses all floats (Binary64) and big floats in labeled boxes. The floats are converted to exact rational form.
After solve exits, numbers are converted back to floats (big floats are converted using the \emph{current} value of \fpprec.

It can, of course, happen that the simplification after conversion back to floats can involve subtractive cancellation. In such cases, purely numerical methods might be better.

\section{Solve function hierarchy}

 The top level function solve function:
 \begin{alphalist}[noitemsep]
   \item resets multiplicities to its default value,
   \item expunges constant variables and duplicates from the list of variables,
   \item checks for inequalities and signals an error when found,
   \item creates a new super context--all assumptions made during solve are removed after exiting,
   \item protects all floats and big floats in labeled boxes,
   \item does gensym substitutions when solving for nonatoms,
   \item dispatches the appropriate lower level solve function,
   \item reverts gensym substitutions for nonatom solve,
   \item unboxes the floats and big floats,
   \item kills the super context.
\end{alphalist}

The lower level solve functions are solve-single-equation (solve one equation in one unknown), redundant-equation-solve (solve two or more equations for one unknown), and solve-multiple-equations (solve two or more equations in two or more unknowns).

\paragraph{solve-single-equation} If the input is a polynomial, dispatch the polynomial solve code.

First the equation is processed using
The primary method for solving one equation in one unknown is to match the equation to the form \(a F(X) - b = 0\), where \(X\) depends on the unknown, the function \(F\) has a known inverse, and \(a\) and \(b\) are free of the unknown \(x\). When the match is successful, the new tasks is to solve \(X = F^{-1}(b/a) \). In general, \(F^{-1}\) is multi-valued--in such cases, the task is to solve finitely many equations of the form  \(X = F^{-1}(b/a) \).

The multi inverses for functions are stored in a Common Lisp hashtable. To accommodate the needs of diverse users,
there are two hashtables; one is named \multivaluedinverse\/ and the other \singlevaluedinverse.  The option
variable \solveinversepackage\/ is the value of the current hashtable for the function multi inverses.

\section{Polynomial zeros}

The zeros of polynomials of degree four or less are expressed in terms of radicals. Also  cyclotomic polynomials of degree six are solved in terms of radicals, as well as polynomial of degree five or greater that decompose into polynomials of degree four or less. \emph{Well there option variable solvedecomp controls using polynomial decomposition, but I think this option could be removed.}

\begin{alphalist}[noitemsep]

\item  Polynomial coefficients that are not simplified to zero by the  general simplifier are assumed to be nonzero. Even if an atom has been declared to be zero, the general simplifier does not simplify  it to zero. Thus even if the atom \(a\) has been declared to be zero, the solution to \(a x = b\) is \(x = -b/a \).



\end{alphalist}



\end{document}
